var y=t=>t&&typeof t=="object"&&!Array.isArray(t),a=(t,...o)=>{if(!o.length)return t;let e=o.shift();if(y(t)&&y(e))for(let n in e)y(e[n])?(t[n]||Object.assign(t,{[n]:{}}),a(t[n],e[n])):Object.assign(t,{[n]:e[n]});return a(t,...o)},i=(t,{freeze:o=!0}={})=>e=>{let n={};return t(n,e!=null?e:{}),o?Object.freeze(n):n},p=(t,...o)=>e=>{let n={};return o.forEach(r=>{n=a(n,r(e))}),t(n,e!=null?e:{}),Object.freeze(n)},u=(t,{log:o=!0,name:e="Time"}={})=>(...n)=>{let r=performance.now(),s=t(...n),c=performance.now()-r;return o&&console.table({[e]:`${c}ms`}),[c,s]},m=(t,{log:o=!0,name:e="Time"}={})=>async(...n)=>{let r=performance.now(),s=await t(...n),c=performance.now()-r;return o&&console.table({[e]:`${c}ms`}),[c,s]},l=t=>{let o=new Map;return(...e)=>{console.log(void 0);let n=JSON.stringify(e);if(o.has(n))return o.get(n);let r=t(...e);return o.set(n,r),r}},x=t=>{let o=new Map;return async(...e)=>{let n=JSON.stringify(e);if(o.has(n))return o.get(n);let r=await t(...e);return o.set(n,r),r}};export{p as extend,i as factory,y as isObject,l as memo,x as memoAsync,a as merge,u as perf,m as perfAsync};
